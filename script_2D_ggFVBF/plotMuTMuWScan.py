#!/usr/bin/env python#  Created on: July 19, 2012__author__ = "Sven Kreiss, Kyle Cranmer"__version__ = "0.1"import ROOT#import AtlasStyle#import AtlasUtilROOT.gROOT.LoadMacro("AtlasStyle.C")ROOT.gROOT.ProcessLine("SetAtlasStyle()")import osimport optparsedef DrawText(xx, yy, text):  l = ROOT.TLatex()  l.SetNDC(1)  l.SetTextSize(0.03)  l.DrawLatex( xx,yy,text )#________________________________________def cb(option, opt_str, value, parser):        '''        Callback function         '''        args=[]        for arg in parser.rargs:                if arg[0] != "-":                        args.append(arg)                else:                        del parser.rargs[:len(args)]                        break        if getattr(parser.values, option.dest):                args.extend(getattr(parser.values, option.dest))        setattr(parser.values, option.dest, args)parser = optparse.OptionParser(version="0.1")parser.add_option("-i", "--inputFiles", help="glob expression for log files", action="callback",callback=cb, dest="inputFiles")parser.add_option("-o", "--outputFile", help="output root file", type="string", dest="outputFile", default="MuTMuW_data.root")parser.add_option(      "--allowNegMu", help="allow negative mu values", dest="allowNegMu", default=True, action="store_true")parser.add_option("-q", "--quiet", dest="verbose", action="store_false", default=True,                   help="Quiet output.")parser.add_option("-t", "--Tag",type="string", dest="Tag",default="")parser.add_option("--MakePlot",                  dest="MakePlot",default=True)(options, args) = parser.parse_args()import glob, refrom array import arraydef main():   files = options.inputFiles    print( "Files: "+str(files) )      NLL = []   for fName in files:      mH = None      #regm = re.search( "_(?P<mH>[-\d|\.]{3,5})", fName )      #if regm: mH = float(regm.groupdict()['mH'])      #print( "Opening %s. Determined mH = %.1f" % (fName,mH) )      mH=125      f = open( fName )      muT = None      for l in f:         # luckily this is filled at the top of the file so it can be used below         regm = re.search( "muT = (?P<muT>[-\d|\.]+)", l )         if regm: muT = float(regm.groupdict()['muT'])         print muT         regm = re.search( "muW = (?P<muW>[-\d|\.]+), NLL = (?P<nll>[-\d|\.]+)", l )         if regm:            muW,nll = (float(regm.groupdict()['muW']), float(regm.groupdict()['nll']))            NLL.append( (nll, muT, muW, mH) )   # filter   if not options.allowNegMu:      NLL = [ v for v in NLL if v[1]>=0.0 and v[2]>=0.0 ]      #print( "All NLL values: "+str(NLL) )   muTValues = set([ v[1] for v in NLL ])   muWValues = set([ v[2] for v in NLL ])   muTStep = (max(muTValues) - min(muTValues))/(len(muTValues)-1)   muWStep = (max(muWValues) - min(muWValues))/(len(muWValues)-1)   print( "(muTStep,muWStep) = (%f,%f)" % (muTStep,muWStep) )   th2 = ROOT.TH2F(      "MuTMuW","MuTMuW;#mu_{ggF} #times B/B_{SM};#mu_{VBF+VH} #times B/B_{SM}; -2 ln #lambda",       len(muTValues), min(muTValues)-muTStep/2, max(muTValues)+muTStep/2,      len(muWValues), min(muWValues)-muWStep/2, max(muWValues)+muWStep/2,      #101, 119.95,130.05,      #80, 0,8,   )   mHMap = ROOT.TH2F(      "mHMap","mHMap;#mu_{ggF} #times B/B_{SM};#mu_{VBF+VH} #times B/B_{SM};mH [GeV]",      len(muTValues), min(muTValues)-muTStep/2, max(muTValues)+muTStep/2,      len(muWValues), min(muWValues)-muWStep/2, max(muWValues)+muWStep/2,      #101, 119.95,130.05,      #80, 0,8,   )   print( "setting minNLL" )   minNLLPoint = ( min(NLL)[1], min(NLL)[2] )   minNLL = min(NLL)[0]      print( "initializing bins to 1e6" )   for i in range( (th2.GetNbinsX()+2)*(th2.GetNbinsY()+2) ):      th2.SetBinContent( i, 1e6 )   print( "setting NLL values" )   for v in NLL:      binNum = th2.FindBin( v[1],v[2] )      xB,yB,zB = (ROOT.Long(0.0),ROOT.Long(0.0),ROOT.Long(0.0))      th2.GetBinXYZ( binNum, xB,yB,zB )      if round(th2.GetBinCenter( xB ),2) != round(v[1],2):         print( "bin center: %f, v1: %f" % (th2.GetBinCenter( xB ),v[1]) )         continue # only fill if mH is exactly equal      #th2.SetBinContent( binNum, 2.*(v[0] - min(NLL)[0]) + 0.000001 )      #th2.SetBinContent( binNum, v[0] )      # only set bin, if the value is smaller than the current content      # --> used for pseudo-profiling of Higgs mass      if th2.GetBinContent( binNum ) > 2.*(v[0] - minNLL):         th2.SetBinContent( binNum, 2.*(v[0] - minNLL) )         mHMap.SetBinContent( binNum, v[3] )   print( "interpolating empty bins" )   for i in range( 1,(th2.GetNbinsX()+2)*(th2.GetNbinsY()+2)-1 ):      if th2.GetBinContent( i ) == 1e6:         th2.SetBinContent( i, (th2.GetBinContent( i-1 )+th2.GetBinContent( i+1 ))/2 )   th2.SetMaximum(25)   th2.SetStats(False)   mHMap.SetStats(False)   mHMap.SetMinimum(120.0)   mHMap.SetMaximum(130.0)      # based on Bill Murray's code   thContour68 = ROOT.TH2F(th2)   thContour95 = ROOT.TH2F(th2)   thContour68.SetName( "Contour68" )   thContour95.SetName( "Contour95" )   thContour68.SetContour(1,array('d',[2.3]))   thContour95.SetContour(1,array('d',[6.0]))   thContour95.SetLineStyle( 2 )   c = ROOT.TCanvas( "c", "c", 800, 600 )   thContour68.Draw("contlist")   c.Update()   listOfGraphs = ROOT.gROOT.GetListOfSpecials().FindObject("contours").At(0)   cont68 = [ ROOT.TGraph( listOfGraphs.At(i) ) for i in range( listOfGraphs.GetSize() ) ]   for co in range( len(cont68) ):      #cont68[co].SetLineStyle( 2 )      cont68[co].SetName( "Contour68TG_%d" % co )   thContour95.Draw("contlist")   c.Update()   listOfGraphs = ROOT.gROOT.GetListOfSpecials().FindObject("contours").At(0)   cont95 = [ ROOT.TGraph( listOfGraphs.At(i) ) for i in range( listOfGraphs.GetSize() ) ]   for co in range( len(cont95) ):      cont95[co].SetLineStyle( 2 )      cont95[co].SetName( "Contour95TG_%d" % co )   bestFit = ROOT.TMarker( minNLLPoint[0], minNLLPoint[1], 3 )   SM = ROOT.TMarker(1 ,1, 34 )   BkdOnly = ROOT.TMarker(0 ,0, 28 )   BkdOnly.SetMarkerColor(1)   SM.SetMarkerColor(4)   bestFit.SetMarkerColor(2)         f = ROOT.TFile( options.outputFile, "RECREATE" )   th2.Write()   mHMap.Write()   thContour68.Write()   thContour95.Write()   for c in cont68: c.Write()   for c in cont95: c.Write()   bestFit.Write("bestFit")   if options.MakePlot:      try:         os.makedirs("Plots/"+options.Tag)      except:         print "Path exists .. "      c = ROOT.TCanvas("","",500,500)      leg = ROOT.TLegend(0.7,0.7,0.9,0.9)      leg.SetFillColor(0)      leg.SetFillStyle(0)      leg.SetBorderSize(0)      cont68[0].Draw("AL")           cont95[0].Draw("L")      cont68[0].SetLineColor(2)      cont68[0].SetLineStyle(2)      cont95[0].SetLineColor(2)      cont95[0].SetLineStyle(1)      bestFit.Draw("SAME")      SM.Draw("SAME")      BkdOnly.Draw("SAME")      leg.AddEntry(bestFit,"best fit","p")      leg.AddEntry(cont95[0],"95% Contour","l")      leg.AddEntry(cont68[0],"68% Contour","l")      leg.AddEntry(SM,"SM prediction","p")      leg.AddEntry(BkdOnly,"Background only","p")      leg.Draw()      cont68[0].GetXaxis().SetRangeUser(-2.5,4)      cont68[0].GetXaxis().SetTitle("#mu_{ggF} #times B/B_{SM}")      cont68[0].GetYaxis().SetTitle("#mu_{VBF+VH} #times B/B_{SM}")      cont68[0].GetYaxis().SetRangeUser(-1,6)      DrawText(0.2,0.9,"#int Ldt = 4.6-20.3 fb^{-1}, #sqrt{s} = 7+8 TeV")      DrawText(0.2,0.84,"H#rightarrow#tau_{had}#tau_{had}")      c.Print("Plots/Contour.pdf".format(options.Tag))   f.Close()         if __name__ == "__main__":   main()